# Toka VM Browser Test

WebAssembly browser integration for testing Toka VM rendering and execution.

## Quick Start

1. Build the WASM package:
   ```bash
   wasm-pack build --target web --out-dir www/pkg
   ```

2. Serve the `www` directory with any static HTTP server:
   ```bash
   # Option 1: Python
   python3 -m http.server 8000

   # Option 2: Node.js
   npx http-server -p 8000

   # Option 3: Rust
   cargo install simple-http-server
   simple-http-server -p 8000
   ```

3. Open browser to http://localhost:8000

## Features

The browser test provides:
- **Interactive Canvas**: 800×600 pixel viewport rendering
- **Example Programs**: Pre-built bytecode examples
  - Arithmetic (2 + 3 = 5)
  - Fill Canvas (red colour test)
  - Blue Rectangle (drawing test)
  - Comparison (2 < 3 logic test)
- **Controls**:
  - Run: Execute program to completion
  - Step: Execute 1000 instructions
  - Reset: Reload current program

## Architecture

```
Rust Builder → VSF Bytecode → WASM VM → Canvas RGBA → ImageData → Browser Canvas
```

### Key Components

1. **[index.html](index.html)**: HTML test harness with canvas and UI
2. **[app.js](app.js)**: JavaScript integration layer
3. **pkg/**: WASM module generated by wasm-pack
   - `toka.js`: JavaScript bindings
   - `toka_bg.wasm`: WebAssembly binary
   - `toka.d.ts`: TypeScript definitions

## Canvas Format Conversion

The VM uses an internal AARRGGBB format (0xAARRGGBB) for efficient opacity checks. When transferring pixels to the browser, we convert to RGBA bytes:

```rust
// One rotate operation per pixel
pub fn to_rgba_bytes(&self) -> Vec<u8> {
    self.pixels
        .iter()
        .flat_map(|&px| px.rotate_left(8).to_be_bytes())
        .collect()
}
```

**Transformation**: AARRGGBB → RRGGBBAA → [RR, GG, BB, AA]
- `rotate_left(8)`: Shifts AARRGGBB to RRGGBBAA (single CPU instruction)
- `to_be_bytes()`: Big-endian extraction gives correct RGBA byte order

This approach is optimal for WASM (~0.5ms for 800×600 canvas).

## Browser API Integration

JavaScript creates ImageData from RGBA bytes:

```javascript
const rgba = vm.get_canvas_rgba();  // Vec<u8> from Rust
const imageData = new ImageData(
    new Uint8ClampedArray(rgba),
    vm.width(),
    vm.height()
);
ctx.putImageData(imageData, 0, 0);
```

## Performance

- WASM binary: ~800KB (optimized with wasm-opt)
- Canvas update: ~0.5ms (800×600 = 480K pixels)
- VM execution: ~1M ops/sec (depending on opcode mix)

## Development

To rebuild after changes:

```bash
# Clean build
rm -rf www/pkg
wasm-pack build --target web --out-dir www/pkg

# Watch for changes (requires cargo-watch)
cargo watch -s 'wasm-pack build --target web --out-dir www/pkg'
```

## Browser Compatibility

Requires:
- WebAssembly support (all modern browsers)
- ES6 modules
- Canvas API with ImageData

Tested on:
- Chrome/Edge 90+
- Firefox 89+
- Safari 15+

## Limitations

Currently the `push` opcode (`.ps()` family in builder) generates valid VSF bytecode but VM doesn't decode VSF values yet. For now, examples use `push_one` and `push_zero` which work perfectly.

This will be implemented in a future version.

## Next Steps

- [ ] Implement VSF value decoder in VM for push opcode
- [ ] Add animation loop support for continuous rendering
- [ ] Implement function calls and jump labels
- [ ] Add debugging UI (stack view, instruction pointer)
- [ ] Performance profiling tools
